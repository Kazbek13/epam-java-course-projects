У попередньому розділі ми розглянули основні прийоми процедурного програмування, за допомогою яких можна створювати окремі функції. Єдиний спосіб зв’язку між ними — можливість взаємного виклику з відповідним обміном параметрами та результатами (якщо не брати до уваги небажану роботу над спільною пам’яттю). Ще раніше було розглянуто способи структурної організації даних, які дають можливість об’єднувати їх у складні агрегати. Тепер переходимо до агрегатів нового рівня — класів, що об’єднують дані — атрибути разом із методами — функціями для їх обробки.
Звернімо увагу на певну розбіжність термінології, застосовуваної в об’єктно-орієнтованому програмуванні загалом, із технічною термінологією мови С++. Якщо в процедурному програмуванні зазвичай уживають термін поле для позначення компонента структури, то в об’єктно-орієнтованому програмуванні заведено говорити про атрибут класу, зокрема й структури, як його часткового випадку. Функції, розміщені в класах, в об’єктно-орієнтованому програмуванні називають методами. Водночас у мові С++ надають перевагу терміну члени класу, які можуть бути як даними, так і функціями. На нашу думку, термін «атрибут» має певну стилістичну перевагу над «даними-членами класу», так само як «метод» — над «функцією-членом класу», і тому ми частіше вживатимемо їх, навіть коли мова йтиме про поняття мови С++.
Домовимося ще про одну пару позначень, надзвичайно важливих для об’єктної парадигми. Її суть полягає в поданні програми як системи взаємодії об’єктів. У рамках послідовного програмування, за які ми не виходитимемо в цьому курсі, у кожний момент часу в програмі, що виконується, виділено один об’єкт, який називають активним. Активність об’єкта означає, що на момент розгляду комп’ютер саме виконує один із його методів. Виконання методу може потребувати звернень до інших об’єктів. У момент звернення об’єкт, який замовив послугу (у термінах об’єктного програмування — «передав повідомлення», краще сказати — «замовлення», sending a message), стає клієнтом (client), а виконавець замовлення — сервером (server). Активність клієнта призупиняється, і сервер стає активним об’єктом програми. Зрозуміло, що статус сервера не заважає об’єкту замовити послугу в іншого сервера й перетворитися на його клієнта. На цьому принципі взаємодії ґрунтується так звана клієнт-серверна архітектура програмних систем, яку після виходу за рамки послідовного програмування можна застосовувати до паралельних і розподілених програмних систем.

Принцип інкапсуляції даних і дій
Так само, як літери збирають у слова, а слова — у твори, із команд формують функції, а з функцій — програми. Деякі твори стають шедеврами, але вони не містять нічого, крім речень, складених зі слів, кожне з яких можна знайти в словнику. Слова складаються лише з тридцяти двох літер алфавіту, але осмислені набори літер становлять лише невелику частину всіх можливих комбінацій. І навіть у цій мізерній частині часто трапляються помилки, хоча орфографія вчить нас правил правопису, а граматика — правил побудови речень. Мова стає багатшою, коли в ній ужито особливі мовні конструкції: елегантні звороти, вишукані ідіоми, крилаті вислови, виразні метафори, змістовні гіперболи тощо. У програмуванні такими особливими мовними конструкціями стали ієрархії з класів і об’єктів, які ілюструють найкращі досягнення програмних архітектур, повною мірою втілюючи слова професора Ніклауса Вірта про те, що програми — це взаємозв’язок алгоритмів і даних.
Важко визначити, що складніше — створювати першокласні твори рідною, але неформальною мовою, чи складати програми мовами формальними. У будь-якому разі ми постійно звертатимемо увагу на те, що можна було б назвати «високим стилем» у програмуванні. Він окрім естетичної форми, так само властивої програмуванню, як і високому стилю в літературі, має чисто прагматичні властивості ефективності, надійності, мобільності тощо.